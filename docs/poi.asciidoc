= Competitive Programming
:y: &#10003;
:ellipsis: …
:stem:
:toc:
:le: &le;

// TODO please reference to the GitHub Pages.

== POI XXII

[cols="^.^1, ^.^1, ^.^1, ^.^1, ^.^4, ^.^4", options="header"]
|====

| stage | problem | status | tags | description | solution

.5+| stage i

| cza | {y}
| dp
| n ({le} 1000000) 个人（编号为 1 \~ n） 围着圆桌坐成一圈。座位相邻的两个人，其
编号之差的绝对值不可以超过 p ({le} 3)。他们之中有些人不喜欢别人。如果 a 不喜欢
b，那么 b 不能坐在a右边的那一个位置上。现在，假设第 n 个人的座位已经固定，要给
剩下的人安排座位，共有几种合法方案？
| p {le} 2 是简单的情况。考虑 p = 3 的时候。我们设，f[i] 表示以 i 开头，i\+1 结
尾，i \~ n 这些数的方案数。g[i] 表示以 i\+1 开头，i 结尾，i \~ n 这些数的方案数
。通过画一个树来枚举可能的情况，我们可以得到递推关系 f[i] = g[i+1] + g[i+2] +
g[i+3] + g[i+5], 类似的可以得到关于 g 的递推关系。当然，边界情况可能会有点问题
，所以当 n-7 {le} i 的时候，我们直接暴力算出答案，否则通过递推得到。当然，题目
还有不喜欢的关系，在递推的时候检查不喜欢的关系即可。最后的答案也可以通过类似递
推的方法算出来。

| kin | {y}
| data structure, segment tree
| 共有 m 部电影，编号为 1 \~ m，第 i 部电影的好看值为 w[i]。在 n 天之中（从
1\~n 编号）每天会放映一部电影，第 i 天放映的是第 f[i] 部。你可以选择 l, r (1
{le} l {le} r {le} n)，并观看第 l, l+1, {ellipsis}, r 天内所有的电影。如果同一
部电影你观看多于一次，你会感到无聊，于是无法获得这部电影的好看值。所以你希望最
大化观看且仅观看过一次的电影的好看值的总和。
| 枚举 i 从 1 到 n，用线段树维护到当前位置的前缀和。对于相同的电影，假设其好看
值是 x，从 i 开始第一次出现是 +x，第二次出现是 -x，后面都是 0。然后从 i 转移到
i\+1 的时候，更新相同电影前一次和前前次对应区间的值即可。

| kwa | {y}
| find the pattern
| 考虑将正整数 n ({le} 10{caret}18) 拆分成几个不同的平方数之和，比如
30=1{caret}2 + 2{caret}2 + 5{caret}2=1{caret}2 \+ 2{caret}2 \+ 3{caret}2 +
4{caret}2，而 8 不存在这样的拆分。 用 k(n) 表示 n 的拆分中，最大的底数最小可能
是多少。如果 n 不存在这样的拆分，则令 k(n)=∞ 。例如，k(1)=1, k(8)=∞ ,
k(378)=12, k(380)=10。定义一个数 x 被称为“超重”的，当且仅当存在 y>x，使得
k(y)<k(x)。从上面的例子可知， 378 是一个“超重”的数。 给定 n，你需要：(1) 求出
k(n) (2) 求出 1\~n 中有几个“超重”的数。
| 一个比较牛逼的找规律题。仅 2, 3, 6, 7, 8, 11, 12, 15, 18, 19, {ellipsis},
108, 112, 128 这 31 个数的 k 值是无穷大的。然后我们设 f(m) = 1{caret}2 +
2{caret}2 + {ellipsis} + m{caret}2，当 n 足够大是，我们设 ind(n) 为第一个满足
f(m) >= n 的 m。现在若 k(f(ind(n)) - n) 是无穷，则 k(n)=ind(n)+1, 否则
k(n)=ind(n)，详细的证明可以参考
https://www.oi.edu.pl/static/attachment/20160714/oi22.pdf[官方题解]。

| las | {y}
| dp
| 圆桌上摆放着 n ({le} 1000000) 份食物，围成一圈，第i份食物所含热量为 c[i]。 相
邻两份食物之间坐着一个人，共有 n 个人。每个人有两种选择，吃自己左边或者右边的食
物。如果两个人选择了同一份食物，这两个人会平分这份食物，每人获得一半的热量。 假
如某个人改变自己的选择后（其他 n-1 个人的选择不变），可以使自己获得比原先更多的
热量，那么这个人会不满意。 请你给每个人指定应该吃哪一份食物，使得所有人都能够满
意。
| 设 f[i][st] 表示第 i 份食物，左右两边的人的状态是 st 能否可行。然后按顺序转移
即可。

| pie | {y}
| simulation
| 一张 n*m 的方格纸，有些格子需要印成黑色，剩下的格子需要保留白色。你有一个 a*b
的印章，有些格子是凸起（会沾上墨水）的。你需要判断能否用这个印章印出纸上的图案
。印的过程中需要满足以下要求：(1) 印章不可以旋转。(2) 不能把墨水印到纸外面。
(3) 纸上的同一个格子不可以印多次。
| 模拟，每次挑左上就行。

.5+| stage ii

| log | {y}
|
|
|

| pod | {y}
|
|
|

| pus | {y}
|
|
|

| kur | {y}
|
|
|

| trz | {y}
|
|
|

.7+| stage iii

| odw | {y}
|
|
|

| myj | {y}
|
|
|

| tab |
|
|
|

| wil | {y}
|
|
|

| kol |
|
|
|

| mod | {y}
|
|
|

| wyc | {y}
|
|
|

|====

