= Competitive Programming
:toc:
:y: &#10003;
:ellipsis: …
:stem:

// TODO please reference to the GitHub Pages.

== Ural

[cols="^.^1, ^.^1, ^.^1, ^.^4, ^.^4", options="header"]
|====

| problem | status | tags | description | solution

| ural1040 | {y}
| gcd, dfs, bazinga
| 给定一个简单图，要用 `1-m` 给每条边无重复编号，使得最后每个点相邻边的标号的 gcd 值为 `1` 。
| 主要到一个点相邻的边只要有两条互质那么整体 gcd 肯定为 `1` ，而且 `1-m` 相邻两
数是互质的，所以只需要做一遍 dfs 就好。

| ural1006 | {y}
| brute-force
| 给定 `N` 个矩形边框重叠后的俯视图（只有重叠部分的字符会被覆盖），让还原一组可能的矩形以及顺序。
| 每次枚举左上角和边长，看看有没有对应的矩形，然后把这个矩形删除后用一个万能字符替代，
只要一个矩形不是全都是万能字符就好。这题比较坑的在于输入输出，用 `char` ，
按字节理解，如果要可视化的化单独写个程序。

| ural1030 | {y}
| math, formulas
| 给定地球表面两点的经度和纬度，求两点在表面上的最短距离。
| Great-circle distance。这个最大圆由两点和球心确定。
设 latexmath:[\phi_1, \lambda_1] 和 latexmath:[\phi_2, \lambda_2] 分别是两点的纬度和经度， latexmath:[\Delta \sigma] 是他们的中心角，则：
latexmath:[\Delta\sigma=\arccos\bigl(\sin\phi_1\cdot\sin\phi_2+\cos\phi_1\cdot\cos\phi_2\cdot\cos(\Delta\lambda)\bigr).]

| ural1042 | {y}
| math, gaussian elimination
| 高斯消元，题目一个隐含条件确保唯一解。
| 只涉及到 `0, 1`, 可以用 `std::bitset<>` 。

| ural1099 | {y}
| graph, 环套树
| 一般图的最大匹配
| Blossom algorithm, 参考 http://www.csie.ntnu.edu.tw/~u91029/Matching.html[这个]

| ural1035 | {y}
| graph, euler paths
| 欧拉路径（环）
| 我们处理每个方格格点，计算正面（背面）线个数，然后将多出来的正面（背面）线个
数累加到对应连通分量的对应正面（背面）个数，假如说某个连通分量正面多出来的线个
数和是 `a`, 背面是 `b`, 那么这个连通分量需要 latexmath:[\min (a, b) + \frac{\mid a-b \mid}{2}] 针。连通分量用并查集维护。

| ural1065 | {y}
| dp, computational geometry
| 给定一个 n(&le; 50) 个点的凸多边形，顶点是哨塔，按照给定的顺序沿多边形巡逻。
现在想减少巡逻距离，可以选择不经过若干哨塔。但是给定 m( &le; 1000) 个纪念碑，
要求纪念碑都在巡逻路线内部，求最短的巡逻路线。
| 为了处理环形关系我们可以将 n 个点复制一遍。然后可以预处理出 i 到 j
这一段左边是不是有纪念碑，然后就可以枚举起点来做 dp，其实也可以 floyd，
最后要记得枚举三个点 i, j, k 来算最短距离，防止算到 i 到 j 然后 j 到 i
这种共线的情况。i, j, k 三个点也不能是共线的。

| ural1097 | {y}
| discretization
| 给定一个 l*l 的正方形，里面有 m( &le; 100) 个不重叠子正方形，每个正方形都有个权重，
现在问一个找 a*a 的子正方形，且重叠到上面子正方形的最大权重最小。空白区域默认为 1。
| 离散化 x, y，然后枚举所有可能坐标，二分权重。

| ural1043 | {y}
| geometry
| 给定圆弧两段点，以及圆弧上一点（都是整点），问用平行坐标轴且顶点坐标的矩形完全覆盖这个圆弧最小面积。
| 点在圆弧上用角度判断就好，都转换到 [0, 2pi)。

| ural1062 | {y}
| geometry, half-plane intersection
| 给定铁人三项每个人每项的速度, 问是否存在一个三种路线的长度使得第 i 个人总时间比所有人都小。
| 假设第一项距离为 x，第二项为 y，那么可以假设第三项为 1-x-y，我们可以得道 n-1
个半平面，然后求交就行。注意还有 x &ge; 0, y &ge; 0, x+y &le; 1。
还有要注意的是得到的直线可能无解，或者全平面，要特殊处理。TODO 随机增量法。

| ural1046 | {y}
| geometry, complex, rotate, equation
| 假设 n 个点的凸多边形，每条边向外有个等腰三角形，顶点为 Mi, 现在已知 Mi
的坐标和角度 ai，求出一组凸多边形顶点坐标。保证有解。
| 我们假设凸多边形第一个顶点坐标为 p0，那么可以在复平面上通过向量旋转得到 p1，
这样绕一圈可以得到一个 p0 关于 p0 的方程。解出 p0 再推出所有点就行。

| ural1041 | {y}
| matroid, greedy, gaussian-elimination
| 给定 m(&le; 2000) 个 n(&le; <= 50) 维向量，每个向量有个价格，求找 n 个线性无关向量的最小价值，
输出字典序最小的一组解。无解输出 0。
| 贪心做，排序后不断取，如果加入当前向量还能线性无关，就加入，顺便把下面的向量当前维度消掉。
做当前向量时要把非零列交换过来。这题用 double 会跪，需要用模素数的整数运算才能过。
支持这套贪心的理论其实就是 matroid。做这题发现还有人写过这个，刘雨辰《对拟阵的初步研究》。TODO

| ural1063 | {y}
| graph, euler paths
| 一个多米若骨牌由两个数字（数字 &le; 6）构成，现在给定 n(&le; 100) 个多米若骨牌，
想将其排成一排，使得相邻头尾相接的数字相等。问要插入怎样的骨牌使得插入骨牌的数字和最小。
| 看着很复杂，其实就是一个顶点数为 6 的图，一个骨牌就是一条边，最后要求的就是一个欧拉路。
不过虽然抽象出来很简单，但是加边情况很多，似乎也没什么好办法。最后暴力连接连通分量，然后贪心连奇数度的边。

| ural1058 |
| geometry
| 给定 n (&le; 50) 的凸多边形，问将其均分成两个面积相等的两半的最短线段长度是多少。
| 需要证明均分面积的最短线段和其切到的两边夹角相等。

| ural1841 | {y}
| data structures
| 给定 n(&le; 10{caret}5) 个首尾相接的线段的 x 坐标，表示一个山从下到上的形状。
每个线段上可能有若干索道，可以直线上升到于下一个线段相交的位置。告诉你每个线段上移动一个单位
x 距离所需要的时间以及每个索道所需要的时间，并且你只能按 y 递增的方向移动，
问到山顶的最短时间。（索道总数不超过 10{caret}5）。
| 我们可以按顺序处理每个区间，看这个区间 x 坐标范围内有多少索道上升过来，
这个可以用 set 的 lower_bound 维护出不小于左边界 l 的位置。也可以用树状数组，
二分出这个位置。
其实我们就是想求 n 个数，每个数右边比如第一个比他大的数，这个其实可以通过单调队列算出来。
不过这种从前往后推的想法好像比较难写。

| ural1977 | {y}
| data structures, segment tree
| 给定 n 个点(&le; 10{caret}9) 个点，每个点每秒会增加 p 单位能量，你有个 repo 可以存储能量，
现在有两种操作，可以在 t 时刻把 l 到 r 的能量都存储到 repo 里，或者在 t 时刻，把 repo
里的能量全部用于增加 i-d+1 到 i+d-1 范围内的点，第 i 个点增加 d*x，与 i 距离为 1 的增加 (d-1)*x，
一直到增加 x 为止，x 通过用尽全部能量可以解除来。操作个数不不超过 10{caret}5，每次存储操作输出 repo 的能量值。
| 我们可以用线段树维护一段区间的和以及一段区间增加的等差数列，维护 a0 和 delta, clear 以及 sum。
然后还有要注意的是题目需要离散化，所以只能离线做了，我离散化的方式是一个节点
维护的坐标区间 [l, r] 实际包括了 r 右边和 r+1 直接没被离散化到的点。然后为了简化处理，
将所有 r 和 r+1 都插入到离散化的点中，这样每次整体区间的 [l, r] r 右边就没有多余的点了，
但是这样比较浪费空间。还有种思路就是增加一个量，维护 extra，表示一次将 [l, r]
划分成 [l, mid] 和 [mid+1, r] 的中间没被维护到的点。这题被卡了一下空间常熟。

| ural1965 | {y}
| dynamic programming
| 给定 n(&le; 10{caret}5) 的一个排列，问能否用两个不相交的单调序列覆盖。
| TODO

| ural2075 | {y}
| data structures, self-balancing binary search tree, avl
| TODO
| TODO

| ural2096 | {y}
| data structures, offline
| TODO
| 如果要强制在线的需要可持久化。不过可以离线做，如果是个链状的结构很简单，一次扫描过去就行，
但是是个树状的结构，那么我们也可以在 dfs 的过程中，当处理完一个节点恢复就行。
这里最坑的是 ural 空间卡的比较紧。用了 std::vector 的 reserve 在 g++ 没什么用，
结果用 clang 就过了 {ellipsis}

| ural2042 | {y}
| data structures, segment tree
| 给定一个长度为 n(&le; 10{caret}5) 的字符串，给定一个数 k(&le; 50)，现在有两种操作，
将一段区间的字符都改成 c，或者询问一段区间长度不超过 k 的回文串的数目。操作数目不超过 (&le; 10{caret}5)。
| 一开始想了一种做法，维护每个区间两端连续不超过 50 的字符串，然后每次合并跑下 manacher，
就能维护出每个区间回文串个数的信息。但是常数太大了。也可以维护每个点为左端点，长度不超过 k 的回文串个数。
假如说有一段区间覆盖 [l, r]，为了简化讨论，假设区间足够长，那么 [l, r-k+1] 的上述值都成 k。
然后还要单独处理 [l-1-k+1, l-1] 以及 [r-k+2, r] 这两段区间。为了降低常数，对这两段区间
的字符串分别做个 manacher，不要一个一个单点修改，一段区间一段区间修改。
事实上常数更低的正确做法是使用 non-recursive segment tree。
参考这个链接 http://codeforces.com/blog/entry/18051[Efficient and easy segment trees] TODO。

|====

== Codeforces

[cols="^.^1, ^.^1, ^.^1, ^.^4, ^.^4", options="header"]
|====

| problem | status | tags | description | solution

| cf906c  | {y}
| dp, tree, connectivity
| 主人认识一些朋友，朋友也可能认识一些朋友，以此类推，现在想让所有人都相互认识，
每一次可以选一个人将他认识的朋友相互介绍认识，问最少进行几次介绍。
| 注意到如果是树的话要介绍的次数是总顶点数减去叶子顶点数。如果是个图，
选出来进行介绍的顶点要连通，其次加上选出来顶点的邻居顶点要包含所有顶点。
我们可以用状态压缩 DP 维护， `connected[state]=true` 。
那么有 `connected[state \| (1<<v)]=true`, `v` 是 `state` 表示节点的一个没被包含的邻居。
最后答案就是最小连通顶点数的 `state` 且满足 `state` 中所有顶点加上其的邻居包含了全部的顶点。

| cf906d | {y}
| math, number theory, euler theorem
|
| if latexmath:[n \geq \varphi(p)], then latexmath:[a^n \equiv a^{n \bmod \varphi(p) + \varphi(p)} \pmod{p}]

| cf906e |
| string
|
|

| cf901b | {y}
| construction
| 求恰好 `n` 步的多项式 Euclid's algorithm。满足所有系数只能是 `-1, 0, 1`
且最高次不能超过 `n`, 第一个多项式的次数要比第二个的大。
| 整数的 Euclid's algorithm 最坏情况在 Fibonacci 数列上发生。对于多项式，
我们可以类似构造 latexmath:[P_{n+1} = x P_n \pm P_{n-1}]，
要注意多项式系数的约束条件。还有一种更好的方式，
latexmath:[P_{n+1} = x P_n + P_{n-1} \mod 2]。


|====


== Other

[cols="^.^1, ^.^1, ^.^1, ^.^3, ^.^3", options="header"]
|====

| problem | status | tags | description | solution

| poj1947 | {y}
| tree dp, pack
| 求使一棵树有一个大小为 p 的独立的子树至少需要删除多少边。
| 树形 dp，对每个顶点的子树做背包。按 dfs 序不断把之前的子树所有状态先处理完实现比较简单。

|====

