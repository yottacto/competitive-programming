= Competitive Programming
:toc:
:y: &#10003;
:le: &le;
:ge: &ge;
:ellipsis: …
:stem:

// TODO please reference to the GitHub Pages.

== Ural

[cols="^.^1, ^.^1, ^.^1, ^.^4, ^.^4", options="header"]
|====

| problem | status | tags | description | solution

| ural1040 | {y}
| gcd, dfs, bazinga
| 给定一个简单图，要用 `1-m` 给每条边无重复编号，使得最后每个点相邻边的标号的 gcd 值为 `1` 。
| 主要到一个点相邻的边只要有两条互质那么整体 gcd 肯定为 `1` ，而且 `1-m` 相邻两
数是互质的，所以只需要做一遍 dfs 就好。

| ural1006 | {y}
| brute-force
| 给定 `N` 个矩形边框重叠后的俯视图（只有重叠部分的字符会被覆盖），让还原一组可能的矩形以及顺序。
| 每次枚举左上角和边长，看看有没有对应的矩形，然后把这个矩形删除后用一个万能字符替代，
只要一个矩形不是全都是万能字符就好。这题比较坑的在于输入输出，用 `char` ，
按字节理解，如果要可视化的化单独写个程序。

| ural1030 | {y}
| math, formulas
| 给定地球表面两点的经度和纬度，求两点在表面上的最短距离。
| Great-circle distance。这个最大圆由两点和球心确定。
设 latexmath:[\phi_1, \lambda_1] 和 latexmath:[\phi_2, \lambda_2] 分别是两点的纬度和经度， latexmath:[\Delta \sigma] 是他们的中心角，则：
latexmath:[\Delta\sigma=\arccos\bigl(\sin\phi_1\cdot\sin\phi_2+\cos\phi_1\cdot\cos\phi_2\cdot\cos(\Delta\lambda)\bigr).]

| ural1042 | {y}
| math, gaussian elimination
| 高斯消元，题目一个隐含条件确保唯一解。
| 只涉及到 `0, 1`, 可以用 `std::bitset<>` 。

| ural1099 | {y}
| graph, 环套树
| 一般图的最大匹配
| Blossom algorithm, 参考 http://www.csie.ntnu.edu.tw/~u91029/Matching.html[这个]

| ural1035 | {y}
| graph, euler paths
| 欧拉路径（环）
| 我们处理每个方格格点，计算正面（背面）线个数，然后将多出来的正面（背面）线个
数累加到对应连通分量的对应正面（背面）个数，假如说某个连通分量正面多出来的线个
数和是 `a`, 背面是 `b`, 那么这个连通分量需要 latexmath:[\min (a, b) + \frac{\mid a-b \mid}{2}] 针。连通分量用并查集维护。

| ural1065 | {y}
| dp, computational geometry
| 给定一个 n({le} 50) 个点的凸多边形，顶点是哨塔，按照给定的顺序沿多边形巡逻。
现在想减少巡逻距离，可以选择不经过若干哨塔。但是给定 m( {le} 1000) 个纪念碑，
要求纪念碑都在巡逻路线内部，求最短的巡逻路线。
| 为了处理环形关系我们可以将 n 个点复制一遍。然后可以预处理出 i 到 j
这一段左边是不是有纪念碑，然后就可以枚举起点来做 dp，其实也可以 floyd，
最后要记得枚举三个点 i, j, k 来算最短距离，防止算到 i 到 j 然后 j 到 i
这种共线的情况。i, j, k 三个点也不能是共线的。

| ural1097 | {y}
| discretization
| 给定一个 l*l 的正方形，里面有 m( {le} 100) 个不重叠子正方形，每个正方形都有个权重，
现在问一个找 a*a 的子正方形，且重叠到上面子正方形的最大权重最小。空白区域默认为 1。
| 离散化 x, y，然后枚举所有可能坐标，二分权重。

| ural1043 | {y}
| geometry
| 给定圆弧两段点，以及圆弧上一点（都是整点），问用平行坐标轴且顶点坐标的矩形完全覆盖这个圆弧最小面积。
| 点在圆弧上用角度判断就好，都转换到 [0, 2pi)。

| ural1062 | {y}
| geometry, half-plane intersection
| 给定铁人三项每个人每项的速度, 问是否存在一个三种路线的长度使得第 i 个人总时间比所有人都小。
| 假设第一项距离为 x，第二项为 y，那么可以假设第三项为 1-x-y，我们可以得道 n-1
个半平面，然后求交就行。注意还有 x {ge} 0, y {ge} 0, x+y {le} 1。
还有要注意的是得到的直线可能无解，或者全平面，要特殊处理。TODO 随机增量法。

| ural1046 | {y}
| geometry, complex, rotate, equation
| 假设 n 个点的凸多边形，每条边向外有个等腰三角形，顶点为 Mi, 现在已知 Mi
的坐标和角度 ai，求出一组凸多边形顶点坐标。保证有解。
| 我们假设凸多边形第一个顶点坐标为 p0，那么可以在复平面上通过向量旋转得到 p1，
这样绕一圈可以得到一个 p0 关于 p0 的方程。解出 p0 再推出所有点就行。

| ural1041 | {y}
| matroid, greedy, gaussian-elimination
| 给定 m({le} 2000) 个 n({le} <= 50) 维向量，每个向量有个价格，求找 n 个线性无关向量的最小价值，
输出字典序最小的一组解。无解输出 0。
| 贪心做，排序后不断取，如果加入当前向量还能线性无关，就加入，顺便把下面的向量当前维度消掉。
做当前向量时要把非零列交换过来。这题用 double 会跪，需要用模素数的整数运算才能过。
支持这套贪心的理论其实就是 matroid。做这题发现还有人写过这个，刘雨辰《对拟阵的初步研究》。TODO

| ural1063 | {y}
| graph, euler paths
| 一个多米若骨牌由两个数字（数字 {le} 6）构成，现在给定 n({le} 100) 个多米若骨牌，
想将其排成一排，使得相邻头尾相接的数字相等。问要插入怎样的骨牌使得插入骨牌的数字和最小。
| 看着很复杂，其实就是一个顶点数为 6 的图，一个骨牌就是一条边，最后要求的就是一个欧拉路。
不过虽然抽象出来很简单，但是加边情况很多，似乎也没什么好办法。最后暴力连接连通分量，然后贪心连奇数度的边。

| ural1058 |
| geometry
| 给定 n ({le} 50) 的凸多边形，问将其均分成两个面积相等的两半的最短线段长度是多少。
| 需要证明均分面积的最短线段和其切到的两边夹角相等。

| ural1841 | {y}
| data structures
| 给定 n({le} 10{caret}5) 个首尾相接的线段的 x 坐标，表示一个山从下到上的形状。
每个线段上可能有若干索道，可以直线上升到于下一个线段相交的位置。告诉你每个线段上移动一个单位
x 距离所需要的时间以及每个索道所需要的时间，并且你只能按 y 递增的方向移动，
问到山顶的最短时间。（索道总数不超过 10{caret}5）。
| 我们可以按顺序处理每个区间，看这个区间 x 坐标范围内有多少索道上升过来，
这个可以用 set 的 lower_bound 维护出不小于左边界 l 的位置。也可以用树状数组，
二分出这个位置。
其实我们就是想求 n 个数，每个数右边比如第一个比他大的数，这个其实可以通过单调队列算出来。
不过这种从前往后推的想法好像比较难写。

| ural1977 | {y}
| data structures, segment tree
| 给定 n 个点({le} 10{caret}9) 个点，每个点每秒会增加 p 单位能量，你有个 repo 可以存储能量，
现在有两种操作，可以在 t 时刻把 l 到 r 的能量都存储到 repo 里，或者在 t 时刻，把 repo
里的能量全部用于增加 i-d+1 到 i+d-1 范围内的点，第 i 个点增加 d*x，与 i 距离为 1 的增加 (d-1)*x，
一直到增加 x 为止，x 通过用尽全部能量可以解除来。操作个数不不超过 10{caret}5，每次存储操作输出 repo 的能量值。
| 我们可以用线段树维护一段区间的和以及一段区间增加的等差数列，维护 a0 和 delta, clear 以及 sum。
然后还有要注意的是题目需要离散化，所以只能离线做了，我离散化的方式是一个节点
维护的坐标区间 [l, r] 实际包括了 r 右边和 r+1 直接没被离散化到的点。然后为了简化处理，
将所有 r 和 r+1 都插入到离散化的点中，这样每次整体区间的 [l, r] r 右边就没有多余的点了，
但是这样比较浪费空间。还有种思路就是增加一个量，维护 extra，表示一次将 [l, r]
划分成 [l, mid] 和 [mid+1, r] 的中间没被维护到的点。这题被卡了一下空间常熟。

| ural1965 | {y}
| dynamic programming
| 给定 n({le} 10{caret}5) 的一个排列，问能否用两个不相交的单调序列覆盖。
| TODO

| ural2075 | {y}
| data structures, self-balancing binary search tree, avl
| 有一个无限高的圆柱形杯子，然后按时间顺序发生一些事件，倒入某种酒 h 高度，将吸管放置在 h 高度，拿出吸管。
酒名的字典序小，密度就大，酒倒入瞬间就会到对应层，两种酒不会混合。如果某时刻吸完了，且紧接着没有酒补充，
那么吸管也将被拿出。喝酒的速度是每个单位时间喝一个单位高度。要求每个喝酒的时间段，酒名，相邻酒名不相同。
| 这些操作都可以用平衡树简单维护出来，暴写就好，写了个 avl {ellipsis}

| ural2096 | {y}
| data structures, offline
| 初始主人（编号 0）有 n({le} 10{caret}5) 个计划，然后有 m({le} 10{caret}5) 个朋友，按顺序编号 1 到 m。
每个朋友首先会有 q 个询问，询问编号比他小的某人的某项计划是什么。然后询问完后，他只会以编号比他小的某人的计划为基础，
然后在此基础上进行 c 个修改，每个修改就是以等差数列的位置修改 k 个计划为一个新的计划。所有 c 的和不超过 10{caret}5，
所有修改计划总数的和不超过 10{caret}5，所有询问不超过 5*10{caret}6。
| 如果要强制在线的需要可持久化。不过可以离线做，如果是个链状的结构很简单，一次扫描过去就行，
但是是个树状的结构，那么我们也可以在 dfs 的过程中，当处理完一个节点恢复就行。
这里最坑的是 ural 空间卡的比较紧。用了 `std::vector` 的 reserve 在 g++ 没什么用，
结果用 clang 就过了 {ellipsis}

| ural1717 | {y}
| data structures
| 抽象下题意，二维空间中 n({le} 1500) 个点，每个点有可正可负的权值，求一个平行坐标轴的子矩形，
使得矩形内点权值和最大。
| 先离散化，就成了 N * N 的矩阵。然后我们扫描子矩形的左边界，然后从这个位置依次像右扫描右边界。
每次扫过一个 x 就累加到对应位置。这样我们要求的最大子矩形其实就是一维的最大字段和。
线段树可以维护出来。

| ural2042 | {y}
| data structures, segment tree
| 给定一个长度为 n({le} 10{caret}5) 的字符串，给定一个数 k({le} 50)，现在有两种操作，
将一段区间的字符都改成 c，或者询问一段区间长度不超过 k 的回文串的数目。操作数目不超过 ({le} 10{caret}5)。
| 一开始想了一种做法，维护每个区间两端连续不超过 50 的字符串，然后每次合并跑下 manacher，
就能维护出每个区间回文串个数的信息。但是常数太大了。也可以维护每个点为左端点，
长度不超过 k 的回文串个数。假如说有一段区间覆盖 [l, r]，为了简化讨论，假设区间足够长，
那么 [l, r-k+1] 的上述值都成 k。然后还要单独处理 [l-1-k+1, l-1] 以及 [r-k+2, r] 这两段区间。
为了降低常数，对这两段区间的字符串分别做个 manacher，不要一个一个单点修改，一段区间一段区间修改。
事实上常数更低的正确做法是使用 non-recursive segment tree。
参考这个链接 http://codeforces.com/blog/entry/18051[Efficient and easy segment trees] TODO。

| ural1887 | {y}
| probability, dp
| 抽象下题意，现在有一个数字生成器，每次可以生成数字 0-9 中的一个，告诉你一次生成中生成每个数字的概率，
问要使生成的数字中 0-9 都出现过的期望生成次数是多少。
| 一个可行的做法是用二进制状态表示每次生成数字的状态，那么我们可以构建一个图，
图中的有向边表示一次生成可以发生的状态变化。该图有自环，除了自环是个 dag，
可以进行递推，自环的情况可以用方程解出来。我们可以用 f[state] 表示从 state
到目标状态 1023 的期望次数，每次转移只要枚举每条边，然后考虑自环解个方程就行。
最后 f[0] 就是答案。

| ural1627 | {y}
| counting, matrix tree theorem
| 给一个无向图，求生成树个数。
| matrix tree theorem 模板题，求行列式的值的时候可以利用行列式性质，例如一行乘以 t 加到另一行值不变，
交换两行值变相反数，行列式某行乘以 k 等于整个行列式值乘 k 等。这个过程类似高斯消元，
但是因为数很大，所以一般求的是行列式取模。而我们又不想引入除法，在消两行的过程中，
可以用类似 gcd 的过程，进行 O(log n) 次乘减，直到一个变为零为止。
当消到上三角或下三角的时候，主对角线的乘积就是行列式的值了。
matrix tree theorem 这里就不详讲了，很巧妙，参考 https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem#An_example_using_the_matrix-tree_theorem[wiki]。
首先你需要得到图的 Laplacian matrix，然后随便去掉一行一列就行列式就好。
wiki 上还有写扩展，比如对于 multigraph 也是适用的，还有就是 graphic matroid 等。TODO。

|====

== Codeforces

contests please refer to https://yottacto.github.io/competitive-programming/codeforces.html[this].

== Other

[cols="^.^1, ^.^1, ^.^1, ^.^3, ^.^3", options="header"]
|====

| problem | status | tags | description | solution

| poj1947 | {y}
| tree dp, pack
| 求使一棵树有一个大小为 p 的独立的子树至少需要删除多少边。
| 树形 dp，对每个顶点的子树做背包。按 dfs 序不断把之前的子树所有状态先处理完实现比较简单。

|====

