== Competitive Programming

:y: &#10003;
:stem:

=== problems

[cols="^.^, ^.^, ^.^, ^.^, ^.^", options="header"]
|====

| problem | status | tags | description | solution

| cf906c  | {y}
| dp, tree, connectivity
| 主人认识一些朋友，朋友也可能认识一些朋友，以此类推，现在想让所有人都相互认识
，每一次可以选一个人将他认识的朋友相互介绍认识，问最少进行几次介绍。
| 注意到如果是树的话要介绍的次数是总顶点数减去叶子顶点数。如果是个图，选出来进行介绍
的顶点要连通，其次加上选出来顶点的邻居顶点要包含所有顶点。我们可以用状态压缩 DP 维护
， `connected[state]=true` 。那么有 `connected[state \| (1<<v)]=true`, `v` 是
`state` 表示节点的一个没被包含的邻居。最后答案就是最小连通顶点数的 `state` 且满足
`state` 中所有顶点加上其的邻居包含了全部的顶点。 latexmath:[a^{\varphi(x)}], latexmath:[a^{\varphi(x)}]

| cf906d | {y}
| math, number theory, euler theorem
|
| if latexmath:[n \geq \varphi(p)], then latexmath:[a^n \equiv a^{n \bmod \varphi(p) + \varphi(p)} \pmod{p}]

| cf906e |
| string
|
|

| cf901b | {y}
| construction
| 求恰好 `n` 步的多项式 Euclid's algorithm。满足所有系数只能是 `-1, 0, 1` 且最
高次不能超过 `n`, 第一个多项式的次数要比第二个的大。
| 整数的 Euclid's algorithm 最坏情况在 Fibonacci 数列上发生。对于多项式，我们可以类似构造 latexmath:[P_{n+1} = x P_n \pm P_{n-1}]，
要注意多项式系数的约束条件。
还有一种更好的方式， latexmath:[P_{n+1} = x P_n + P_{n-1} \mod 2]。

| poj1947 | {y}
| tree dp, pack
| 求使一棵树有一个大小为 p 的独立的子树至少需要删除多少边。
| 树形 dp，对每个顶点的子树做背包。按 dfs 序不断把之前的子树所有状态先处理完实现比较简单。

| poj3259 | {y}
| shortest-path, negative circle
|
| spfa, 一个点出现超过 `n` 次即有负环。

|====

