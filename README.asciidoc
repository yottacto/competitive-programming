= Competitive Programming
:toc:
:y: &#10003;
:stem:

// TODO please reference to the GitHub Pages.

== Ural

[cols="^.^1, ^.^1, ^.^1, ^.^4, ^.^4", options="header"]
|====

| problem | status | tags | description | solution

| ural1040 | {y}
| gcd, dfs, bazinga
| 给定一个简单图，要用 `1-m` 给每条边无重复编号，使得最后每个点相邻边的标号的 gcd 值为 `1` 。
| 主要到一个点相邻的边只要有两条互质那么整体 gcd 肯定为 `1` ，而且 `1-m` 相邻两
数是互质的，所以只需要做一遍 dfs 就好。

| ural1006 | {y}
| brute-force
| 给定 `N` 个矩形边框重叠后的俯视图（只有重叠部分的字符会被覆盖），让还原一组可能的矩形以及顺序。
| 每次枚举左上角和边长，看看有没有对应的矩形，然后把这个矩形删除后用一个万能字
符替代，只要一个矩形不是全都是万能字符就好。这题比较坑的在于输入输出，用 `char`
，按字节理解，如果要可视化的化单独写个程序。

| ural1030 | {y}
| math, formulas
| 给定地球表面两点的经度和纬度，求两点在表面上的最短距离。
| Great-circle distance。这个最大圆由两点和球心确定。
设 latexmath:[\phi_1, \lambda_1] 和 latexmath:[\phi_2, \lambda_2] 分别是两点的纬度和经度， latexmath:[\Delta \sigma] 是他们的中心角，则：
latexmath:[\Delta\sigma=\arccos\bigl(\sin\phi_1\cdot\sin\phi_2+\cos\phi_1\cdot\cos\phi_2\cdot\cos(\Delta\lambda)\bigr).]

| ural1042 | {y}
| math, gaussian elimination
| 高斯消元，题目一个隐含条件确保唯一解。
| 只涉及到 `0, 1`, 可以用 `std::bitset<>` 。

| ural1099 | {y}
| graph, 环套树
| 一般图的最大匹配
| Blossom algorithm, 参考 http://www.csie.ntnu.edu.tw/~u91029/Matching.html[这个]

| ural1035 | {y}
| graph
| 欧拉路径（环）
| 我们处理每个方格格点，计算正面（背面）线个数，然后将多出来的正面（背面）线个
数累加到对应连通分量的对应正面（背面）个数，假如说某个连通分量正面多出来的线个
数和是 `a`, 背面是 `b`, 那么这个连通分量需要 latexmath:[\min (a, b) + \frac{\mid a-b \mid}{2}] 针。连通分量用并查集维护。

| ural1065 | {y}
| dp, computational geometry
| 给定一个 n(&le; 50) 个点的凸多边形，顶点是哨塔，按照给定的顺序沿多边形巡逻。现在
想减少巡逻距离，可以选择不经过若干哨塔。但是给定 m( &le; 1000) 个纪念碑，要求纪念碑
都在巡逻路线内部，求最短的巡逻路线。
| 为了处理环形关系我们可以将 n 个点复制一遍。然后可以预处理出 i 到 j 这一段左边
是不是有纪念碑，然后就可以枚举起点来做 dp，其实也可以 floyd，最后要记得枚举三个
点 i, j, k 来算最短距离，防止算到 i 到 j 然后 j 到 i 这种共线的情况。i, j, k 三
个点也不能是共线的。

| ural1097 | {y}
| discretization
| 给定一个 l*l 的正方形，里面有 m( &le; 100) 个不重叠子正方形，每个正方形都有个权重，
现在问一个找 a*a 的子正方形，且重叠到上面子正方形的最大权重最小。空白区域默认为 1。
| 离散化 x, y，然后枚举所有可能坐标，二分权重。

| ural1043 | {y}
| geometry
| 给定圆弧两段点，以及圆弧上一点（都是整点），问用平行坐标轴且顶点坐标的矩形完
全覆盖这个圆弧最小面积。
| 点在圆弧上用角度判断就好，都转换到 [0, 2pi)。

| ural1062 | {y}
| geometry, half-plane intersection
| 给定铁人三项每个人每项的速度, 问是否存在一个三种路线的长度使得第 i 个人总时间
比所有人都小。
| 假设第一项距离为 x，第二项为 y，那么可以假设第三项为 1-x-y，我们可以得道 n-1
个半平面，然后求交就行。注意还有 x &ge; 0, y &ge; 0, x+y &le; 1。还有要注意的是
得到的直线可能无解，或者全平面，要特殊处理。

|====

== Codeforces

[cols="^.^1, ^.^1, ^.^1, ^.^4, ^.^4", options="header"]
|====

| problem | status | tags | description | solution

| cf906c  | {y}
| dp, tree, connectivity
| 主人认识一些朋友，朋友也可能认识一些朋友，以此类推，现在想让所有人都相互认识
，每一次可以选一个人将他认识的朋友相互介绍认识，问最少进行几次介绍。
| 注意到如果是树的话要介绍的次数是总顶点数减去叶子顶点数。如果是个图，选出来进行介绍
的顶点要连通，其次加上选出来顶点的邻居顶点要包含所有顶点。我们可以用状态压缩 DP 维护
， `connected[state]=true` 。那么有 `connected[state \| (1<<v)]=true`, `v` 是
`state` 表示节点的一个没被包含的邻居。最后答案就是最小连通顶点数的 `state` 且满足
`state` 中所有顶点加上其的邻居包含了全部的顶点。

| cf906d | {y}
| math, number theory, euler theorem
|
| if latexmath:[n \geq \varphi(p)], then latexmath:[a^n \equiv a^{n \bmod \varphi(p) + \varphi(p)} \pmod{p}]

| cf906e |
| string
|
|

| cf901b | {y}
| construction
| 求恰好 `n` 步的多项式 Euclid's algorithm。满足所有系数只能是 `-1, 0, 1` 且最
高次不能超过 `n`, 第一个多项式的次数要比第二个的大。
| 整数的 Euclid's algorithm 最坏情况在 Fibonacci 数列上发生。对于多项式，我们可
以类似构造 latexmath:[P_{n+1} = x P_n \pm P_{n-1}]，要注意多项式系数的约束条件
。还有一种更好的方式， latexmath:[P_{n+1} = x P_n + P_{n-1} \mod 2]。


|====


== Other

[cols="^.^1, ^.^1, ^.^1, ^.^3, ^.^3", options="header"]
|====

| problem | status | tags | description | solution

| poj1947 | {y}
| tree dp, pack
| 求使一棵树有一个大小为 p 的独立的子树至少需要删除多少边。
| 树形 dp，对每个顶点的子树做背包。按 dfs 序不断把之前的子树所有状态先处理完实
现比较简单。

|====

