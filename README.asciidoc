= Competitive Programming
:toc:
:y: &#10003;
:stem:

== Ural

[cols="^.^1, ^.^1, ^.^1, ^.^4, ^.^4", options="header"]
|====

| problem | status | tags | description | solution

| ural1040 | {y}
| gcd, dfs, bazinga
| 给定一个简单图，要用 `1-m` 给每条边无重复编号，使得最后每个点相邻边的标号的 gcd 值为 `1` 。
| 主要到一个点相邻的边只要有两条互质那么整体 gcd 肯定为 `1` ，而且 `1-m` 相邻两
数是互质的，所以只需要做一遍 dfs 就好。

| ural1006 | {y}
| brute-force
| 给定 `N` 个矩形边框重叠后的俯视图（只有重叠部分的字符会被覆盖），让还原一组可能的矩形以及顺序。
| 每次枚举左上角和边长，看看有没有对应的矩形，然后把这个矩形删除后用一个万能字
符替代，只要一个矩形不是全都是万能字符就好。这题比较坑的在于输入输出，用 `char`
，按字节理解，如果要可视化的化单独写个程序。

| ural1030 | {y}
| math, formulas
| 给定地球表面两点的经度和纬度，求两点在表面上的最短距离。
| Great-circle distance。这个最大圆由两点和球心确定。
设 latexmath:[\phi_1, \lambda_1] 和 latexmath:[\phi_2, \lambda_2] 分别是两点的纬度和经度， latexmath:[\Delta \sigma] 是他们的中心角，则：
latexmath:[\Delta\sigma=\arccos\bigl(\sin\phi_1\cdot\sin\phi_2+\cos\phi_1\cdot\cos\phi_2\cdot\cos(\Delta\lambda)\bigr).]

| ural1042 | {y}
| math, gaussian elimination
| 高斯消元，题目一个隐含条件确保唯一解。
| 只涉及到 `0, 1`, 可以用 `std::bitset<>` 。

| ural1099 | {y}
| graph, 环套树
| 一般图的最大匹配
| Blossom algorithm, 参考 http://www.csie.ntnu.edu.tw/~u91029/Matching.html[这个]

| ural1035 | {y}
| graph
| 欧拉路径（环）
| 我们处理每个方格格点，计算正面（背面）线个数，然后将多出来的正面（背面）线个
数累加到对应连通分量的对应正面（背面）个数，假如说某个连通分量正面多出来的线个
数和是 `a`, 背面是 `b`, 那么这个连通分量需要 latexmath:[\min (a, b) + \frac{\mid a-b \mid}{2}] 针。连通分量用并查集维护。

| ural1065 | {y}
| dp, computational geometry
| TODO
| TODO
|====


== Codeforces

[cols="^.^1, ^.^1, ^.^1, ^.^4, ^.^4", options="header"]
|====

| problem | status | tags | description | solution

| cf906c  | {y}
| dp, tree, connectivity
| 主人认识一些朋友，朋友也可能认识一些朋友，以此类推，现在想让所有人都相互认识
，每一次可以选一个人将他认识的朋友相互介绍认识，问最少进行几次介绍。
| 注意到如果是树的话要介绍的次数是总顶点数减去叶子顶点数。如果是个图，选出来进行介绍
的顶点要连通，其次加上选出来顶点的邻居顶点要包含所有顶点。我们可以用状态压缩 DP 维护
， `connected[state]=true` 。那么有 `connected[state \| (1<<v)]=true`, `v` 是
`state` 表示节点的一个没被包含的邻居。最后答案就是最小连通顶点数的 `state` 且满足
`state` 中所有顶点加上其的邻居包含了全部的顶点。 latexmath:[a^{\varphi(x)}], latexmath:[a^{\varphi(x)}]

| cf906d | {y}
| math, number theory, euler theorem
|
| if latexmath:[n \geq \varphi(p)], then latexmath:[a^n \equiv a^{n \bmod \varphi(p) + \varphi(p)} \pmod{p}]

| cf906e |
| string
|
|

| cf901b | {y}
| construction
| 求恰好 `n` 步的多项式 Euclid's algorithm。满足所有系数只能是 `-1, 0, 1` 且最
高次不能超过 `n`, 第一个多项式的次数要比第二个的大。
| 整数的 Euclid's algorithm 最坏情况在 Fibonacci 数列上发生。对于多项式，我们可
以类似构造 latexmath:[P_{n+1} = x P_n \pm P_{n-1}]，要注意多项式系数的约束条件
。还有一种更好的方式， latexmath:[P_{n+1} = x P_n + P_{n-1} \mod 2]。


|====


== Other

[cols="^.^1, ^.^1, ^.^1, ^.^3, ^.^3", options="header"]
|====

| problem | status | tags | description | solution

| poj1947 | {y}
| tree dp, pack
| 求使一棵树有一个大小为 p 的独立的子树至少需要删除多少边。
| 树形 dp，对每个顶点的子树做背包。按 dfs 序不断把之前的子树所有状态先处理完实
现比较简单。

|====

